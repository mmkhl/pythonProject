# Расширенный алгоритм Евклида
# Даны два натуральных числа a и b. Найдите их наибольший общий делитель d
# и два таких целых числа x и y, что ax+by=d. Программа должна вывести числа d, x, y.

#
def gcd_extended(num1, num2):
    if num1 == 0:
        return (num2, 0, 1)
    else:
        div, x, y = gcd_extended(num2 % num1, num1)
    return (div, y - (num2 // num1) * x, x)

a = gcd_extended(426, 334)
print(f'Делитель равен {a[0]}, x = {a[1]}, y = {a[2]}')
#
# # Делитель равен 2, x = 69, y = -88
# #
# #
# # # Дан список. Определите, является ли он монотонно возрастающим(то есть верно ли,
# # # что каждый элемент этого списка больше предыдущего).
# # # Выведите YES, если массив монотонно возрастает и NO в противном случае.
# # # Решение оформите в виде функции IsAscending(A).В данной функции должен быть один цикл while,
# # # не содержащий вложенных условий и циклов — используйте схему линейного поиска.
# #
# def IsAscending(A):
#     i = 1
#     while i <= len(A) - 1 and A[i] > A[i - 1]:
#         i += 1
#     return 'YES' if i == len(A) else 'NO'
#
# A = input("Введите последовательность через пробел: ").split(' ')
# print('Введенная последовательность: ', A)
#
# print(IsAscending(A))
# #
# #
# #
# # # Дано слово, состоящее только из заглавных и строчных латинских букв. Проверьте, верно ли что это слово читается
# # # одинаково как справа налево, так и слева направо (то есть является палиндромом), если считать заглавные и строчные
# # # буквы не различающимися. Выведите слово YES, если слово является палиндромом и слово NO, если не является.
# # #
# # # Решение оформите в виде функции IsPalindrome (S), возвращающей значение типа bool. При решении этой задачи
# # # нельзя пользоваться вспомогательными массивами или строками.
# #
# def IsPalindrome(S):
#     S = S.lower()
#     return S == S[::-1]
#     S = S.lower()
#     return S == S[::-1]
# S = input()
# if IsPalindrome(S):
#     print('YES')
# else:
#     print('NO')
#
#
#
#
# # Дан двумерный массив размером n×m (n, m < 1000). Симметричный ему относительно главной диагонали массив
# # называется транспонированным к данному. Он имеет размеры m×n: строки исходного массива становятся столбцами
# # транспонированного, столбцы исходного массива становятся строками транспонированного.
# # Для данного массива постройте транспонированный массив и выведите его на экран.
#
# n, m = map(int, input().split())
# matrix = [list(map(int, input().split())) for _ in range(n)]
#
# for row in list(zip(*matrix)):
#     print(*row)
#
# # В файле могут быть записаны десятичные цифры и все, что угодно. Числом назовем
# # последовательность цифр, идущих подряд (т.е. число всегда неотрицательно).
# # Вычислите сумму всех чисел, записанных в файле. В данной задаче удобно считывать данные посимвольно.


import re # импортируем модуль регулярных выражений

inp = open('input.txt', 'r')
out = open('output.txt', 'a')
summ = 0

numbers = inp.read() # читаем файл
numbers = re.findall(r'[+-]?\d+', numbers) # находим все числа без/с префиксами + и -
numbers = [int(x) for x in numbers] # приводим числа к типу int с помощью list comprehension

# # суммируем числа
# for x in numbers:
#     summ += x
#
# out.write(str(summ)) # записываем результат, обязательно в виде строки
#
# inp.close()
# out.close()


# Каждый из N школьников некоторой школы знает Mi языков. Определите, какие языки знают все школьники
# и языки, которые знает хотя бы один из школьников.
# 1≤N≤1000 , 1≤Mi≤500

# Входные данные
# Первая строка входных данных содержит количество школьников N. Далее идет N чисел Mi, после каждого из
# чисел идет Mi строк, содержащих названия языков, которые знает i-й школьник. Длина названий языков не
# превышает 1000 символов, количество различных языков не более 1000. 1≤N≤1000, 1≤Mi≤500.
#
# Выходные данные
# В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки -
# список таких языков. Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список
# таких языков.



# union = set()
# all = set()
# for i in range(int(input())):
#     m = int(input())
#     a = {input() for j in range(m)}
#     all.update(a)
#     if i == 1:
#         union.update(a)
#     else:
#         union &= a
# print(len(union))
# print('\n'.join(sorted(union)))
# print(len(all))
# print('\n'.join(sorted(all)))